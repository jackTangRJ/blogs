{"meta":{"title":"小唐的前端博客","subtitle":"程序员晋级之路","description":"前端小白成长之路，与我一同进步","author":"JackTang","url":"https://jacktangrj.github.io"},"pages":[],"posts":[{"title":"JSON对象","slug":"JSON","date":"2018-06-05T01:53:12.000Z","updated":"2018-06-05T07:30:56.576Z","comments":true,"path":"2018/06/JSON/","link":"","permalink":"https://jacktangrj.github.io/2018/06/JSON/","excerpt":"JSON的优点 相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。","text":"JSON的优点 相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准。 1.JSON 格式 每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值。 JSON 对值的类型和格式有严格的规定 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN,Infinity , -Infinity和undefined）。 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 注意: null 、空数组和空对象都是合法的 JSON 值。 2.JSON 静态方法JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：JSON.stringify() JSON.parse() 2.1 &nbsp;&nbsp;JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合JSON格式 ，并且可以被JSON.parse方法还原。 1.如果对象的属性是undefined、函数、或XML对象，Json.stringify会过滤2.如果数组的成员是undefined、函数、或XML对象，Json.stringify，则这些值会转为null3.正则对象会被转化为空对象4.Json.stringify会忽略对象不可遍历熟悉5.对于原始类型的值，转换结果会自带双引号。6.Json.stringify方法会忽略对象的不可遍历属性 var obj = {}; Object.defineProperties(obj, { ‘foo’: { value: 1 enumerable: true }, ‘bar’: { value: 2 enumerable: false } }); console.log(JSON.stringify(obj);) // “{“foo”:1}” Json.stringify的第二个参数 JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。 参数为数组： 只对对象的属性有效，对数组无效 参数为函数 ：用来更改JSON.stringify的返回值，中间过滤操作,如果处理函数返回undefined或没有返回值，则改属性会被忽略 console.log( JSON.stringify([‘a’, ‘b’], [‘0’]) ) // “[“a”,”b”]” console.log( JSON.stringify({0: ‘a’, 1: ‘b’}, [‘0’]) ) // “{“0”:”a”}” function f(key, value) { if (typeof value === “number”) value = 2 * value; } return value; } JSON.stringify({ a: 1, b: 2 }, f) // ‘{“a”: 2,”b”: 4}’ Json.stringify的第三个参数 JSON.stringify还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。 2.1.2 &nbsp;&nbsp;JSON.parse方法用于将 JSON 字符串转换成对应的值。 如果传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错 为了处理解析错误，可以将JSON.parse方法放在try…catch代码块中。 try { JSON.parse(“‘String’”); } catch(e) { console.log(‘parsing error’); } JSON.parse方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify方法类似. 3.参数对象的 toJSON 方法 如果参数对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。","categories":[],"tags":[]},{"title":"ES6中proxy拦截对象","slug":"proxy","date":"2018-06-04T03:40:40.000Z","updated":"2018-06-04T07:54:28.260Z","comments":true,"path":"2018/06/proxy/","link":"","permalink":"https://jacktangrj.github.io/2018/06/proxy/","excerpt":"Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。","text":"Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 问题抛出定义一个对象，指定对象sex属性不能重写，抛出错误 来看看ES3的写法 123456789101112131415161718192021222324//es3拦截方法function ProxyEs3() &#123; var obj = &#123; name:&apos;小明&apos;, sex:&quot;男&quot; &#125;; this.get = function (key) &#123; if(key in obj)&#123; return obj[key] &#125;else&#123; throw new ReferenceError(&apos;混蛋，没有这个属性,重写！！&apos;) &#125; &#125;; this.set = function (key,value) &#123; if(key===&apos;sex&apos;)&#123; throw new ReferenceError(&apos;该属性只能读，不能重写&apos;) &#125;else&#123; obj[key] = value &#125; &#125;&#125;var es3P1 = new ProxyEs3();es3P1.set(&quot;sex&quot;,&apos;女&apos;);console.log(es3P1.get(&apos;sex&apos;)); 在试试ES5的写法 12345678910//es5拦截方法var obj = &#123; name:&apos;小明&apos;&#125;;Object.defineProperty(obj,&quot;sex&quot;,&#123; value:&apos;女&apos;, writable:false&#125;);obj.sex = &apos;李四&apos;; //未报错console.log(obj.sex); //女 ES5方法通过定义对象的属性来解决属性只读的效果，但是对不能读写的属性赋值时，控制台不报错.对遍历，对其他操作对象的方法未布置属性 来看看ES6终极写法 12345678910111213141516171819202122//es6拦截方法const obj = &#123; name:&apos;小明&apos;, sex:&apos;女&apos;&#125;;const proxy = new Proxy(obj, &#123; get(target, prop) &#123; if(prop in target)&#123; return target[prop] &#125;else&#123; throw new TypeError(&apos;没有这个属性&apos;); &#125; &#125;, set(target,prop,value)&#123; if (prop === &apos;sex&apos;) &#123; throw new TypeError(&apos;sex属性只能读&apos;); &#125; obj[prop] = value; &#125;&#125;);proxy.sex = &apos;张三&apos;; //报错 TypeError: sex属性只能读 Proxy 支持的拦截操作一览，一共 13 种,列举常用的 1.get(target, propKey, receiver)：拦截对象属性的读取 2.set(target, propKey, value, receiver):拦截对象属性的设置 3.has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值 4.deleteProperty(target, propKey)拦截delete proxy[propKey]的操作，返回一个布尔值。 5.ownKeys(target)：Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 6.defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值 7.getPrototypeOf(target)拦截Object.getPrototypeOf(proxy)，返回一个对象。。 8.setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 9.apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 10.construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 实例：Web 服务的客户端Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。 123456const service = createWebService(&apos;http://example.com/data&apos;);service.employees().then(json =&gt; &#123; const employees = JSON.parse(json); // ···&#125;); 上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。 1234567function createWebService(baseUrl) &#123; return new Proxy(&#123;&#125;, &#123; get(target, propKey, receiver) &#123; return () =&gt; httpGet(baseUrl+&apos;/&apos; + propKey); &#125; &#125;);&#125;","categories":[],"tags":[]},{"title":"解析作用域链及闭包","slug":"scope","date":"2018-06-01T01:29:25.000Z","updated":"2018-06-04T09:23:51.206Z","comments":true,"path":"2018/06/scope/","link":"","permalink":"https://jacktangrj.github.io/2018/06/scope/","excerpt":"前言 作为一名程序员，作用域和闭包在JavaScript里非常重要，作用域与闭包一直是js中的难点，且面试必考。本文我们来聊一聊JavaScript作用域和闭包到底是什么 。","text":"前言 作为一名程序员，作用域和闭包在JavaScript里非常重要，作用域与闭包一直是js中的难点，且面试必考。本文我们来聊一聊JavaScript作用域和闭包到底是什么 。 一、作用域与作用域链作用域作用域与执行上下文的区别 javascript的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，讲代码翻译成可执行代码，这个阶段作用域规则会被确定。 执行阶段由引擎完成，执行可执行代码部分，执行上下文在这个阶段被创建 我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及this的值会分别被确定。 作用域链，是由当前环境与上层环境的一系列变量对象组成，他保证了当前执行环境对符合访问权限的变量和函数的有序访问 1234567891011121314var a = 20;function test() &#123; var b = a + 10; function innerTest() &#123; var c = 10; return b + c; &#125; return innerTest();&#125;test(); 在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。 1234innerTestEC = &#123; VO: &#123;...&#125;, // 变量对象 scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链&#125; 注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，使用AO来表示(Active Object) 作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。 二、闭包对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。 闭包是一种特殊的对象它由两部分组成。执行上下文(代号A)，以及在该执行上下文中创建的函数（代号B）。当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。 在大多数理解中，包括许多著名的书籍，文章里都以函数B的名字代指这里生成的闭包。而在chrome中，则以执行上下文A的函数名代指闭包 因此我们只需要知道，一个闭包对象，由A、B共同组成，在以后的篇幅中，我将以chrome的标准来称呼 1234567891011121314// demo01function foo() &#123; var a = 20; var b = 30; function bar() &#123; return a + b; &#125; return bar;&#125;var bar = foo();bar(); 上面的例子，首先有执行上下文foo，在foo中定义了函数bar，而通过对外返回bar的方式让bar得以执行。当bar执行时，访问了foo内部的变量a，b。因此这个时候闭包产生。 而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。 先来一个简单的例子。 123456789101112131415var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); // 2 在上面的例子中，foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过fn = innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。 这样，我们就可以称foo为闭包。 我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况 在上面的图中，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。 所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量个人认为，从应用层面，这是闭包最重要的特性 对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会是什么呢 1234567891011121314151617var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误 console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; var c = 100; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); 为啥会抛出错误，留给你思考。 闭包的应用场景除了面试，在实践中，闭包有两个非常重要的应用场景。分别是模块化与柯里化。 模块 123456789101112131415(function () &#123; var a = 10; var b = 20; function add(num1, num2) &#123; var num1 = !!num1 ? num1 : a; var num2 = !!num2 ? num2 : b; return num1 + num2; &#125; window.add = add;&#125;)();add(10, 20); 在上面的例子中，使用函数自执行的方式，创建了一个模块，add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。 为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。 利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125;","categories":[],"tags":[]},{"title":"搞定this","slug":"jsThis","date":"2018-05-30T00:53:12.000Z","updated":"2018-06-05T02:07:52.663Z","comments":true,"path":"2018/05/jsThis/","link":"","permalink":"https://jacktangrj.github.io/2018/05/jsThis/","excerpt":"前言 为什么要学习this？如果你学过面向对象编程，那你肯定知道干什么用的，如果你没有学过，那么暂时可以不用看这篇文章，当然如果你有兴趣也可以看看，毕竟这是js中必须要掌握的东西。","text":"前言 为什么要学习this？如果你学过面向对象编程，那你肯定知道干什么用的，如果你没有学过，那么暂时可以不用看这篇文章，当然如果你有兴趣也可以看看，毕竟这是js中必须要掌握的东西。 首先我们需要得出一个非常重要一定要牢记于心的结论，this的指向是在函数被调用的时候确定的也就是执行上下文被创建时确定的。 因此，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。 1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; console.log(this.a);&#125;fn(); // 10fn.call(obj); // 20 在函数执行过程中，this一旦被确定，就不可更改了。 1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; this = obj; // 这句话试图修改this，运行后会报错 console.log(this.a);&#125;fn(); 一、全局对象中的this局环境中的this，指向它本身 12345678910111213// 通过this绑定到全局对象this.a2 = 20;// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身var a1 = 10;// 仅仅只有赋值操作，标识符会隐式绑定到全局对象a3 = 30;// 输出结果会全部符合预期console.log(a1);console.log(a2);console.log(a3); 二、函数中的this123456// demo01var a = 20;function fn() &#123; console.log(this.a); //20&#125;fn(); 123456789// demo02var a = 20;function fn() &#123; function foo() &#123; console.log(this.a);//20 &#125; foo();&#125;fn(); 123456789101112// demo03var a = 20;var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125;&#125;console.log(obj.c); //40console.log(obj.fn()); //10 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。 12345678// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局function fn() &#123; &apos;use strict&apos;; console.log(this);&#125;fn(); // fn是调用者，独立调用 输出undefinedwindow.fn(); // fn是调用者，被window所拥有 输出window 那么我们修改一下demo03的代码，大家可以思考一下会发生什么变化。 12345678910111213141516&apos;use strict&apos;;var a = 20;function foo () &#123; var a = 1; var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125; &#125; return obj.c;&#125;console.log(window.foo()); // 40console.log(foo()); // Uncaught TypeError: Cannot read property &apos;a&apos; of undefined ==如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。== 再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。 123456789101112var a = 20;var foo = &#123; a: 10, getA: function () &#123; return this.a; &#125;&#125;console.log(foo.getA()); // 10var test = foo.getA;console.log(test()); // 20 foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。 稍微修改一下代码，大家自行理解。 123456789var a = 20;function getA() &#123; return this.a;&#125;var foo = &#123; a: 10, getA: getA&#125;console.log(foo.getA()); // 10 灵机一动，再来一个。如下例子。 123456789101112131415function foo() &#123; console.log(this.a)&#125;function active(fn) &#123; fn(); // 真实调用者，为独立调用&#125;var a = 20;var obj = &#123; a: 10, getA: foo&#125;active(obj.getA); //20 严格模式输出undefined 三、使用call，apply显示指定thisJavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。 如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。 12345678function fn() &#123; console.log(this.a);&#125;var obj = &#123; a: 20&#125;fn.call(obj); 而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。 123456789function fn(num1, num2) &#123; console.log(this.a + num1 + num2);&#125;var obj = &#123; a: 20&#125;fn.call(obj, 100, 10); // 130fn.apply(obj, [20, 10]); // 50 因为call/apply的存在，这让JavaScript变得十分灵活。因此就让call/apply拥有了很多有用处的场景。简单总结几点，也欢迎大家补充。 将类数组对象转换为数组 1234567891011121314151617181920function exam(a, b, c, d, e) &#123; // 先看看函数的自带属性 arguments 什么是样子的 console.log(arguments); // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变 var arg = [].slice.call(arguments); console.log(arg);&#125;exam(2, 8, 9, 10, 3);// result:// &#123; &apos;0&apos;: 2, &apos;1&apos;: 8, &apos;2&apos;: 9, &apos;3&apos;: 10, &apos;4&apos;: 3 &#125;// [ 2, 8, 9, 10, 3 ]//// 也常常使用该方法将DOM中的nodelist转换为数组// [].slice.call( document.getElementsByTagName(&apos;li&apos;) ); 根据自己的需要灵活修改this指向 12345678910var foo = &#123; name: &apos;joker&apos;, showName: function() &#123; console.log(this.name); &#125;&#125;var bar = &#123; name: &apos;rose&apos;&#125;foo.showName.call(bar); 实现继承 1234567891011121314151617181920212223// 定义父级的构造函数var Person = function(name, age) &#123; this.name = name; this.age = age; this.gender = [&apos;man&apos;, &apos;woman&apos;];&#125;// 定义子类的构造函数var Student = function(name, age, high) &#123; // use call Person.call(this, name, age); this.high = high;&#125;Student.prototype.message = function() &#123; console.log(&apos;name:&apos;+this.name+&apos;, age:&apos;+this.age+&apos;, high:&apos;+this.high+&apos;, gender:&apos;+this.gender[0]+&apos;;&apos;);&#125;new Student(&apos;xiaom&apos;, 12, &apos;150cm&apos;).message();// result// ----------// name:xiaom, age:12, high:150cm, gender:man; 简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了继承。Student的构造函数等同于下。 12345678var Student = function(name, age, high) &#123; this.name = name; this.age = age; this.gender = [&apos;man&apos;, &apos;woman&apos;]; // Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承 this.high = high;&#125; 在向其他执行上下文的传递中，确保this的指向保持不变 如下面的例子中，我们期待的是getA被obj调用时，this指向obj，但是由于匿名函数的存在导致了this指向的丢失，在这个匿名函数中this指向了全局，因此我们需要想一些办法找回正确的this指向。 12345678910var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;, 1000) &#125;&#125;obj.getA(); 常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这方法，但是我们也要借助上面讲到过的知识，来判断this是否在传递中被修改了，如果没有被修改，就没有必要这样使用了。123456789var obj = &#123; a: 20, getA: function() &#123; var self = this; setTimeout(function() &#123; console.log(self.a) &#125;, 1000) &#125;&#125; 另外就是借助闭包与apply方法，封装一个bind方法。 12345678910111213141516function bind(fn, obj) &#123; return function() &#123; return fn.apply(obj, arguments); &#125;&#125;var obj = &#123; a: 20, getA: function() &#123; setTimeout(bind(function() &#123; console.log(this.a) &#125;, this), 1000) &#125;&#125;obj.getA(); 当然，也可以使用ES5中已经自带的bind方法。它与我上面封装的bind方法是一样的效果。 12345678var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;.bind(this), 1000) &#125;&#125; 四、构造函数与原型方法上的this结合下面的例子，我在例子抛出几个问题大家思考一下。 1234567891011121314151617function Person(name, age) &#123; // 这里的this指向了谁? this.name = name; this.age = age; &#125;Person.prototype.getName = function() &#123; // 这里的this又指向了谁？ return this.name;&#125;// 上面的2个this，是同一个吗，他们是否指向了原型对象？var p1 = new Person(&apos;Nick&apos;, 20);p1.getName(); 通过new操作符调用构造函数，会经历以下4个阶段。 创建一个新的对象； 将构造函数的this指向这个新对象； 指向构造函数的代码，为这个对象添加属性，方法等 返回新对象。 因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。 而原型方法上的this就好理解多了，根据上边对函数中this的定义，p1.getName()中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。","categories":[],"tags":[]},{"title":"github新建博客并绑定阿里云域名","slug":"createBlog","date":"2018-05-28T00:53:12.000Z","updated":"2018-06-05T01:50:09.719Z","comments":true,"path":"2018/05/createBlog/","link":"","permalink":"https://jacktangrj.github.io/2018/05/createBlog/","excerpt":"前言 其实平时自己写的文章并不多，偶尔看到一些东西会做点笔记，但是每次写的东西都会到处放，不好找，所以才想着自己搭建一个人博客网站。 具体步骤如下：安装NodeJs-&gt;安装hexo-&gt;生成SSH并添加到github-&gt;部署项目-&gt;上传到github-&gt;绑定个人域名","text":"前言 其实平时自己写的文章并不多，偶尔看到一些东西会做点笔记，但是每次写的东西都会到处放，不好找，所以才想着自己搭建一个人博客网站。 具体步骤如下：安装NodeJs-&gt;安装hexo-&gt;生成SSH并添加到github-&gt;部署项目-&gt;上传到github-&gt;绑定个人域名 1.到Node.js官方网址下载对应版本1输入 node -v 出现版本号即为成功 2.安装Git 到官方网址下载对应的版本 Git各平台下载地址：https://git-scm.com/download Windows平台Git下载地址：https://git-scm.com/download/win 检查Git版本 1输入 git --version 3.GitHubPages配置 进入GitHub官网https://github.com/注册账号 新建项目 在建好的项目右侧有Settings 向下拉可看到GitHub Pages 点击对应的网址你会发现该项目已经被部署到网络上，你可以通过外网来访问它。 4.安装Hexo在自己认为合适的地方创建一个文件夹，用来存放之后博客的文档以及配置文件，我是在C盘新建了文件夹，并命名为Blogs。然后点击进入创建的文件夹，点击鼠标右键选择Git Bash Here 1输入 npm install hexo -g 开始安装Hexo 输入 npm install hexo -g 开始安装Hexo 1输入 hexo -v 检查是否安装成功 初始化该文件夹 1输入 hexo init 这个过程也有点漫长需要等待几分钟，最后出现Start blogging with Hexo！是不是很激动！！ 开始安装所需要的组件(也可通过淘宝源 cnpm install安装)1输入 npm install 最后两步你就可以看到博客雏形了 1输入 hexo g 1输入 hexo s 骚年，打开你的浏览器 输入 http://localhost:4000/ 开启博客之旅 5.Hexo连接GithubPages将Hexo与GithubPages联系起来，首次运行的话这里需要设置Git的user name和emailctrl+C结束之前的sever 123输入 git config --global user.name &quot;tangrenjie&quot; 改成你自己的即可 123输入 git config --g global user.email &quot;406067361@qq.com&quot; 改成你自己的即可 1.首先需要检查你电脑是否已经有 SSH key运行 git Bash 客户端，输入如下代码： 12$ cd ~/.ssh$ ls 这两个命令就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3。 2、创建一个 SSH key1$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 添加密钥到ssh-agent 1输入 eval &quot;$(ssh-agent -s)&quot; 添加生成的SSH key到ssh-agent 1输入 ssh-add ~/.ssh/id_rsa 代码参数含义： -t 指定密钥类型，默认是 rsa ，可以省略。-C 设置注释文字，比如邮箱。-f 指定密钥文件存储文件名。 3、添加你的 SSH key 到 github上面去a、首先你需要拷贝 id_rsa.pub 文件的内容，你可以用编辑器打开文件复制，也可以用git命令复制该文件的内容，如： 1$ clip &lt; ~/.ssh/id_rsa.pub b、登录你的github账号，从又上角的设置（ Account Settings ）进入，然后点击菜单栏的 SSH key 进入页面添加 SSH key。 6.配置Deploy在你的博客所在文件夹根目录，例如我的是在C:\\Blogs 找到_config.yml文件，点击编辑，我是用的nodepad++打开的 ==这里需要注意的是格式一定是：后跟一个空格，名称对应自己的GitHub项目名称== 到这里基本上博客已经搭建成功 7.发布文章安装扩展 1输入 npm install hexo-deployer-git --save 1输入 hexo new &quot;Hexo教程&quot; 此时在我的 C:\\Blogs\\source_posts 下会出现 Hexo教程.md文件 1输入 hexo g 编译，每次改动上传都要执行此操作 1输入 hexo d 上传，等待一段时间就可以到github上去看已经提交了 8.安装主题Concise，一款为hexo设计的简约而漂亮的主题 克隆主题1$ git clone https://github.com/huangjunhui/concise.git themes/concise 启用修改你的博客根目录下的config.yml配置文件中的theme属性，将其修改为concise 更新$ cd themes/concise $ git pull 更新前，请先备份你的themes/concise/_config.yml文件。 更多请浏览 concise官网 9.绑定阿里云域名1.ping 一下你的github地址 我的github为 https://jacktangrj.github.io 2.打开阿里云 3.更改hexo 打开本地文件地址，在source文件夹下添加CHANGE文件（==注意 没有后缀名==），里面的内容为你的域名 123输入 hexo g hexo d 提交至github 4.在github上修改 5.稍等一会，即可看到效果 结束","categories":[],"tags":[]}]}