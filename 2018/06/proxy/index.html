<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ES6中proxy拦截对象 · 小唐的前端博客</title><meta name="description" content="ES6中proxy拦截对象 - JackTang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/ico.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://jacktangrj.github.io/atom.xml" title="小唐的前端博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/ico.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首 页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">所有文章</a></li><li class="nav-list-item"><a href="http://blog.tanwei888.com" target="_blank" class="nav-list-link">前端每日一课</a></li><li class="nav-list-item"><a href="https://github.com/jackTangRJ/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ES6中proxy拦截对象</h1><div class="post-info">Jun 4, 2018</div><div class="post-content"><p><img src="http://www.wailian.work/images/2018/06/04/timg.th.jpg" alt="image"></p>
<blockquote>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
</blockquote>
<a id="more"></a>
<h4 id="问题抛出"><a href="#问题抛出" class="headerlink" title="问题抛出"></a>问题抛出</h4><p><strong>定义一个对象，指定对象sex属性不能重写，抛出错误</strong></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 来看看ES3的写法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//es3拦截方法</span><br><span class="line">function ProxyEs3() &#123;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        name:&apos;小明&apos;,</span><br><span class="line">        sex:&quot;男&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.get = function (key) &#123;</span><br><span class="line">        if(key in obj)&#123;</span><br><span class="line">            return obj[key]</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            throw new ReferenceError(&apos;混蛋，没有这个属性,重写！！&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    this.set = function (key,value) &#123;</span><br><span class="line">        if(key===&apos;sex&apos;)&#123;</span><br><span class="line">            throw new ReferenceError(&apos;该属性只能读，不能重写&apos;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            obj[key] = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var es3P1 = new ProxyEs3();</span><br><span class="line">es3P1.set(&quot;sex&quot;,&apos;女&apos;);</span><br><span class="line">console.log(es3P1.get(&apos;sex&apos;));</span><br></pre></td></tr></table></figure>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 在试试ES5的写法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//es5拦截方法</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&apos;小明&apos;</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(obj,&quot;sex&quot;,&#123;</span><br><span class="line">    value:&apos;女&apos;,</span><br><span class="line">    writable:false</span><br><span class="line">&#125;);</span><br><span class="line">obj.sex = &apos;李四&apos;; //未报错</span><br><span class="line">console.log(obj.sex); //女</span><br></pre></td></tr></table></figure>
<p>ES5方法通过定义对象的属性来解决属性只读的效果，但是对不能读写的属性赋值时，控制台不报错.对遍历，对其他操作对象的方法未布置属性</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 来看看ES6终极写法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//es6拦截方法</span><br><span class="line">const obj = &#123;</span><br><span class="line">    name:&apos;小明&apos;,</span><br><span class="line">    sex:&apos;女&apos;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(obj, &#123;</span><br><span class="line">    get(target, prop) &#123;</span><br><span class="line">        if(prop in target)&#123;</span><br><span class="line">            return target[prop]</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            throw new TypeError(&apos;没有这个属性&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target,prop,value)&#123;</span><br><span class="line">        if (prop === &apos;sex&apos;) &#123;</span><br><span class="line">            throw new TypeError(&apos;sex属性只能读&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        obj[prop] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.sex = &apos;张三&apos;; //报错  TypeError: sex属性只能读</span><br></pre></td></tr></table></figure>
<p>Proxy 支持的拦截操作一览，一共 13 种,列举常用的 </p>
<h5 id="1-get-target-propKey-receiver-："><a href="#1-get-target-propKey-receiver-：" class="headerlink" title="1.get(target, propKey, receiver)："></a>1.get(target, propKey, receiver)：</h5><p>拦截对象属性的读取</p>
<h5 id="2-set-target-propKey-value-receiver"><a href="#2-set-target-propKey-value-receiver" class="headerlink" title="2.set(target, propKey, value, receiver):"></a>2.set(target, propKey, value, receiver):</h5><p>拦截对象属性的设置</p>
<h5 id="3-has-target-propKey-："><a href="#3-has-target-propKey-：" class="headerlink" title="3.has(target, propKey)："></a>3.has(target, propKey)：</h5><p>拦截propKey in proxy的操作，返回一个布尔值</p>
<h5 id="4-deleteProperty-target-propKey"><a href="#4-deleteProperty-target-propKey" class="headerlink" title="4.deleteProperty(target, propKey)"></a>4.deleteProperty(target, propKey)</h5><p>拦截delete proxy[propKey]的操作，返回一个布尔值。</p>
<h5 id="5-ownKeys-target-："><a href="#5-ownKeys-target-：" class="headerlink" title="5.ownKeys(target)："></a>5.ownKeys(target)：</h5><p>Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</p>
<h5 id="6-defineProperty-target-propKey-propDesc-："><a href="#6-defineProperty-target-propKey-propDesc-：" class="headerlink" title="6.defineProperty(target, propKey, propDesc)："></a>6.defineProperty(target, propKey, propDesc)：</h5><p>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值</p>
<h5 id="7-getPrototypeOf-target"><a href="#7-getPrototypeOf-target" class="headerlink" title="7.getPrototypeOf(target)"></a>7.getPrototypeOf(target)</h5><p>拦截Object.getPrototypeOf(proxy)，返回一个对象。<br>。</p>
<h5 id="8-setPrototypeOf-target-proto-："><a href="#8-setPrototypeOf-target-proto-：" class="headerlink" title="8.setPrototypeOf(target, proto)："></a>8.setPrototypeOf(target, proto)：</h5><p>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
<h5 id="9-apply-target-object-args-："><a href="#9-apply-target-object-args-：" class="headerlink" title="9.apply(target, object, args)："></a>9.apply(target, object, args)：</h5><p>拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</p>
<h5 id="10-construct-target-args-："><a href="#10-construct-target-args-：" class="headerlink" title="10.construct(target, args)："></a>10.construct(target, args)：</h5><p>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p>
<h3 id="实例：Web-服务的客户端"><a href="#实例：Web-服务的客户端" class="headerlink" title="实例：Web 服务的客户端"></a>实例：Web 服务的客户端</h3><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const service = createWebService(&apos;http://example.com/data&apos;);</span><br><span class="line"></span><br><span class="line">service.employees().then(json =&gt; &#123;</span><br><span class="line">  const employees = JSON.parse(json);</span><br><span class="line">  // ···</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createWebService(baseUrl) &#123;</span><br><span class="line">  return new Proxy(&#123;&#125;, &#123;</span><br><span class="line">    get(target, propKey, receiver) &#123;</span><br><span class="line">      return () =&gt; httpGet(baseUrl+&apos;/&apos; + propKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2018/06/JSON/" class="prev">PREV</a><a href="/2018/06/scope/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://jacktangrj.github.io">JackTang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>